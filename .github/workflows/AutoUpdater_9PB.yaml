name: Update VPN Subscription (SUB_9PB)

on:
  schedule:
    - cron: "0 */4 * * *"  # Runs every 4 hours
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'If true, only generate YAML locally without pushing'
        required: false
        default: 'false'

jobs:
  update:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repo
      uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Install dependencies
      run: npm install axios js-yaml

    - name: Run subscription updater
      run: |
        cat > updater.js <<'EOF'
        const fs = require('fs');
        const path = require('path');
        const axios = require('axios');
        const yaml = require('js-yaml');

        const token = process.env.GITHUB_TOKEN;
        const repo = process.env.GITHUB_REPOSITORY;
        const dryRun = process.env.DRY_RUN === 'true';
        const subUrls = process.env.SUB_9PB.split(/\s+/).filter(Boolean);
        const textdbUrl = "https://api.textdb.dev/api/data/SUB_9PB";

        // ---------------- Proxy Parsers ----------------
        function parseVmess(node, name) {
          try {
            const decoded = JSON.parse(Buffer.from(node.split('vmess://')[1], 'base64').toString());
            return {
              name,
              type: 'vmess',
              server: decoded.add,
              port: decoded.port,
              uuid: decoded.id,
              alterId: decoded.aid || 0,
              cipher: decoded.cipher || 'auto',
              tls: decoded.tls === 'tls',
              network: decoded.net || 'tcp',
              'ws-opts': decoded.net === 'ws' ? { path: decoded.path || '/', headers: { Host: decoded.host || '' } } : undefined
            };
          } catch {
            return null;
          }
        }

        function parseVless(node, name) {
          try {
            const url = new URL(node);
            return {
              name,
              type: 'vless',
              server: url.hostname,
              port: parseInt(url.port, 10),
              uuid: url.username,
              tls: url.searchParams.get('security') === 'tls',
              network: url.searchParams.get('type') || 'tcp',
              'ws-opts': url.searchParams.get('type') === 'ws'
                ? { path: url.searchParams.get('path') || '/', headers: { Host: url.searchParams.get('host') || '' } }
                : undefined
            };
          } catch {
            return null;
          }
        }

        function parseTrojan(node, name) {
          try {
            const url = new URL(node);
            return {
              name,
              type: 'trojan',
              server: url.hostname,
              port: parseInt(url.port, 10),
              password: url.password,
              sni: url.searchParams.get('sni') || undefined
            };
          } catch {
            return null;
          }
        }

        function parseHysteria2(node, name) {
          try {
            const url = new URL(node);
            return {
              name,
              type: 'hysteria2',
              server: url.hostname,
              port: parseInt(url.port, 10),
              password: url.password || 'password',
              sni: url.searchParams.get('sni') || undefined,
              udp: url.searchParams.get('udp') === 'true'
            };
          } catch {
            return null;
          }
        }

        function parseAnytls(node, name) {
          try {
            const url = new URL(node);
            return {
              name,
              type: 'anytls',
              server: url.hostname,
              port: parseInt(url.port, 10),
              password: url.password || 'password',
              sni: url.searchParams.get('sni') || undefined
            };
          } catch {
            return null;
          }
        }

        // ---------------- Loader ----------------
        async function loadProxies(url) {
          try {
            const res = await axios.get(url, { timeout: 20000 });
            let raw = Buffer.from(res.data, 'base64').toString('utf-8');

            // ✅ FIX: remove first two lines if they are "proxies:" and "- ..."
            let lines = raw.split(/\r?\n/).filter(l => l.trim() !== "");
            if (lines[0] && lines[0].trim().toLowerCase() === "proxies:") {
              lines.shift(); // remove "proxies:"
            }
            if (lines[0] && lines[0].trim().startsWith("-")) {
              lines.shift(); // remove "- ..." header
            }
            raw = lines.join("\n");

            const nodes = raw.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
            const proxies = [];
            let idx = 1;

            for (const node of nodes) {
              let proxy = null;
              const name = `Node-${idx}`;
              if (node.startsWith('vmess://')) proxy = parseVmess(node, name);
              else if (node.startsWith('vless://')) proxy = parseVless(node, name);
              else if (node.startsWith('trojan://')) proxy = parseTrojan(node, name);
              else if (node.startsWith('hysteria2://')) proxy = parseHysteria2(node, name);
              else if (node.startsWith('anytls://')) proxy = parseAnytls(node, name);

              if (proxy) proxies.push(proxy);
              idx++;
            }
            return proxies;
          } catch (err) {
            console.error("loadProxies failed for", url, err.message);
            return [];
          }
        }

        // ---------------- Main ----------------
        (async () => {
          let allProxies = [];
          for (const url of subUrls) {
            const proxies = await loadProxies(url);
            console.log(`Loaded ${proxies.length} proxies from ${url}`);
            allProxies = allProxies.concat(proxies);
          }

          console.log(`Total proxies collected: ${allProxies.length}`);

          const template = fs.readFileSync(path.join(__dirname, 'ClashTemplate.ini'), 'utf-8');

          const proxies_yaml_block = yaml.dump(allProxies);
          const proxy_names_block = allProxies.map(p => p.name).join('\n');

          const outputContent = template
            .replace('{{PROXIES}}', proxies_yaml_block)
            .replace('{{PROXY_NAMES}}', proxy_names_block);

          fs.writeFileSync('9PB', outputContent);
          fs.writeFileSync('9PB.yml', proxies_yaml_block);

          // --- TextDB Upload ---
          try {
            const resp = await axios.post(
              textdbUrl,
              new URLSearchParams({ value: yaml.dump(allProxies) }).toString(),
              { headers: { "Content-Type": "application/x-www-form-urlencoded" } }
            );
            console.log("✅ Textdb uploaded successfully:", resp.status);
          } catch (err) {
            console.error("❌ Textdb upload failed:", err.message);
          }

          // --- GitHub Update ---
          if (!dryRun) {
            const url = `https://api.github.com/repos/${repo}/contents/9PB`;
            const shaResp = await axios.get(url, { headers: { Authorization: `token ${token}` } });
            const sha = shaResp.data.sha;
            await axios.put(url, {
              message: `Auto update 9PB at ${new Date().toISOString()}`,
              content: Buffer.from(outputContent).toString('base64'),
              sha
            }, { headers: { Authorization: `token ${token}` } });
            console.log("✅ GitHub updated successfully");
          } else {
            console.log("⚠️ Dry-run mode, skipping GitHub update");
          }
        })();
        EOF

        node updater.js

    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: SUB_9PB
        path: 9PB.yml

    - name: Cleanup old artifacts
      uses: actions/github-script@v7
      with:
        script: |
          const artifacts = await github.rest.actions.listArtifactsForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
          });
          const old = artifacts.data.artifacts
            .filter(a => a.name === "SUB_9PB")
            .slice(2);
          for (const art of old) {
            await github.rest.actions.deleteArtifact({
              owner: context.repo.owner,
              repo: context.repo.repo,
              artifact_id: art.id,
            });
            console.log(`🗑 Deleted old artifact: ${art.id}`);
          }
