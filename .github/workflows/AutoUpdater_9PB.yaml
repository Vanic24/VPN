name: Update VPN Subscription (SUB_9PB)

on:
  schedule:
    - cron: '0 */4 * * *' # every 4 hours
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Set true to run without committing'
        required: false
        default: 'false'

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install axios js-yaml

      - name: Run AutoUpdater Script
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SUB_9PB: ${{ secrets.SUB_9PB }}
          DRY_RUN: ${{ github.event.inputs.dry_run }}
        run: |
          node <<'JS'
          const fs = require('fs');
          const path = require('path');
          const axios = require('axios');
          const yaml = require('js-yaml');
          const { URL } = require('url');

          const dry_run = process.env.DRY_RUN === 'true';
          const subUrl = process.env.SUB_9PB;
          const githubToken = process.env.GITHUB_TOKEN;
          const githubRepo = process.env.GITHUB_REPOSITORY || '';

          if (!subUrl) {
            console.error('âŒ SUB_9PB environment variable is not set.');
            process.exit(1);
          }

          function b64decode(s) {
            if (!s) return '';
            s = s.trim();
            // Add padding if needed
            if (s.length % 4) s += '='.repeat(4 - (s.length % 4));
            return Buffer.from(s, 'base64').toString('utf8');
          }

          function safeNumber(v, fallback = 0) {
            const n = Number(v);
            return Number.isFinite(n) ? n : fallback;
          }

          function parseVmess(line) {
            try {
              const payload = line.startsWith('vmess://') ? line.slice(8) : line;
              const conf = JSON.parse(b64decode(payload));
              const net = (conf.net || conf.network || "tcp").toLowerCase();
              const tls = ((conf.tls || conf.security || '') + '').toLowerCase() === 'tls';
              const proxy = {
                name: conf.ps || conf.name || 'vmess',
                type: 'vmess',
                server: conf.add || conf.server,
                port: safeNumber(conf.port, 0),
                uuid: conf.id || conf.uuid || conf.user || '',
                alterId: safeNumber(conf.aid || conf.alterId || 0, 0),
                cipher: conf.type || conf.cipher || 'auto',
                tls,
                network: net
              };
              if (net === 'ws') proxy['ws-opts'] = { path: conf.path || conf.wsPath || '', headers: { Host: conf.host || conf.hostname || '' } };
              if (net === 'grpc') proxy['grpc-opts'] = { 'grpc-service-name': conf.path || conf.serviceName || '' };
              if (conf.sni) proxy.servername = conf.sni;
              return proxy;
            } catch (e) {
              // malformed vmess
              return null;
            }
          }

          function parseVless(line) {
            try {
              // Expect full vless:// URL, but handle cases where slice was done earlier
              const url = line.startsWith('vless://') ? new URL(line) : new URL('vless://' + line);
              const q = Object.fromEntries(url.searchParams.entries());
              const net = (q.type || q.transport || 'tcp').toLowerCase();
              const tls = ((q.security || '') + '').toLowerCase() === 'tls';
              const name = decodeURIComponent((url.hash && url.hash.length > 1) ? url.hash.slice(1) : (q.name || 'vless'));
              const proxy = {
                name,
                type: 'vless',
                server: url.hostname,
                port: safeNumber(url.port || q.port || 443, 443),
                uuid: decodeURIComponent(url.username || ''),
                tls,
                network: net
              };
              if (net === 'ws') proxy['ws-opts'] = { path: q.path || q.wsPath || '', headers: { Host: q.host || '' } };
              if (net === 'grpc') proxy['grpc-opts'] = { 'grpc-service-name': q.serviceName || q['service-name'] || q.service || '' };
              if (q.sni) proxy.servername = q.sni;
              return proxy;
            } catch (e) {
              return null;
            }
          }

          function parseTrojan(line) {
            try {
              // trojan://password@host:port?params#name  OR trojan://host:port?params#name (username in place)
              const u = line.startsWith('trojan://') ? new URL(line) : new URL('trojan://' + line);
              const q = Object.fromEntries(u.searchParams.entries());
              const net = (q.type || q.transport || 'tcp').toLowerCase();
              const tls = ((q.security || '') + '').toLowerCase() === 'tls';
              const name = decodeURIComponent((u.hash && u.hash.length > 1) ? u.hash.slice(1) : 'trojan');
              const proxy = {
                name,
                type: 'trojan',
                server: u.hostname,
                port: safeNumber(u.port || q.port || 443, 443),
                password: decodeURIComponent(u.username || q.password || ''),
                tls,
                network: net
              };
              if (net === 'ws') proxy['ws-opts'] = { path: q.path || '', headers: { Host: q.host || '' } };
              if (net === 'grpc') proxy['grpc-opts'] = { 'grpc-service-name': q.serviceName || q['service-name'] || '' };
              return proxy;
            } catch (e) {
              return null;
            }
          }

          function parseHysteria2(line) {
            try {
              // hysteria2://username@host:port?params#name
              const u = line.startsWith('hysteria2://') ? new URL(line) : new URL('hysteria2://' + line);
              const name = decodeURIComponent((u.hash && u.hash.length > 1) ? u.hash.slice(1) : 'hysteria2');
              return {
                name,
                type: 'hysteria2',
                server: u.hostname,
                port: safeNumber(u.port || 0, 0),
                password: decodeURIComponent(u.username || ''),
                udp: u.searchParams.get('udp') === 'true',
                sni: u.searchParams.get('sni') || undefined,
                'skip-cert-verify': u.searchParams.get('skip-cert-verify') === 'true'
              };
            } catch (e) {
              // fallback: some subs might just include the whole line as a single identifier
              return { name: line, type: 'hysteria2', server: line, port: 0 };
            }
          }

          function parseAnytls(line) {
            try {
              const u = line.startsWith('anytls://') ? new URL(line) : new URL('anytls://' + line);
              const name = decodeURIComponent((u.hash && u.hash.length > 1) ? u.hash.slice(1) : 'anytls');
              return {
                name,
                type: 'anytls',
                server: u.hostname,
                port: safeNumber(u.port || 0, 0),
                password: decodeURIComponent(u.username || ''),
                udp: u.searchParams.get('udp') === 'true',
                sni: u.searchParams.get('sni') || undefined,
                'skip-cert-verify': u.searchParams.get('skip-cert-verify') === 'true'
              };
            } catch (e) {
              return { name: line, type: 'anytls', server: line, port: 0 };
            }
          }

          async function fetchSubscription() {
            const res = await axios.get(subUrl, { responseType: 'text' });
            return res.data;
          }

          async function generate9PB() {
            // Fetch and decode subscription
            const raw = await fetchSubscription();
            const decoded = b64decode(raw.trim());
            // Split lines, remove empty lines and remove first two info lines (commonly present)
            let lines = decoded.split(/\r?\n/).filter(Boolean);
            if (lines.length >= 2 && lines[0].startsWith('#')) {
              // If first line is comment/info, remove first two lines if present
              lines = lines.slice(2);
            } else {
              // Some subs don't have info lines; still attempt to skip the first if it's an info-only line
              // But do not crash: we'll just keep all lines.
            }

            const proxies = [];
            for (let rawLine of lines) {
              const line = rawLine.trim();
              if (!line) continue;

              try {
                if (line.startsWith('vmess://')) {
                  const p = parseVmess(line);
                  if (p) proxies.push(p);
                } else if (line.startsWith('vless://')) {
                  const p = parseVless(line);
                  if (p) proxies.push(p);
                } else if (line.startsWith('trojan://')) {
                  const p = parseTrojan(line);
                  if (p) proxies.push(p);
                } else if (line.startsWith('hysteria2://')) {
                  const p = parseHysteria2(line);
                  if (p) proxies.push(p);
                } else if (line.startsWith('anytls://')) {
                  const p = parseAnytls(line);
                  if (p) proxies.push(p);
                } else {
                  // Some subs mix YAML or plain proxy lines (ignore for now)
                }
              } catch (err) {
                console.error('Failed to parse line:', line, err && err.message ? err.message : err);
              }
            }

            // Remove falsy entries and duplicates by server+port+type (basic dedupe)
            const seen = new Set();
            const uniqueProxies = [];
            for (const p of proxies.filter(Boolean)) {
              const key = `${p.type}||${p.server}||${p.port}||${p.name}`;
              if (!seen.has(key)) {
                seen.add(key);
                uniqueProxies.push(p);
              }
            }

            console.log(`ðŸ”¹ Total proxies parsed: ${uniqueProxies.length}`);
            console.log('Proxy names sample:', uniqueProxies.slice(0, 10).map(p => p.name).join(', '));

            // Load template
            const templatePath = path.join(__dirname, 'ClashTemplate.ini');
            if (!fs.existsSync(templatePath)) {
              console.error('âŒ ClashTemplate.ini not found at', templatePath);
              process.exit(1);
            }
            const template = fs.readFileSync(templatePath, 'utf-8');

            // Build YAML blocks
            const proxies_yaml_block = yaml.dump(uniqueProxies, { lineWidth: -1 }).trimEnd();
            // Build proxy names block (list)
            const proxy_names_block = uniqueProxies.map(p => p.name).join('\n');

            // Replace placeholders (all occurrences)
            let outputContent = template.replace(/{{PROXIES}}/g, proxies_yaml_block);
            outputContent = outputContent.replace(/{{PROXY_NAMES}}/g, proxy_names_block);

            // Write output files
            fs.writeFileSync('9PB', outputContent, 'utf8');
            fs.writeFileSync('9PB.yml', outputContent, 'utf8');

            console.log('âœ… Local files written: 9PB, 9PB.yml');

            if (!dry_run) {
              // Update GitHub file
              const ghUrl = `https://api.github.com/repos/${githubRepo}/contents/9PB`;
              try {
                const ghRes = await axios.get(ghUrl, {
                  headers: { Authorization: `token ${githubToken}`, 'User-Agent': 'github-action' }
                });
                const sha = ghRes.data.sha;
                await axios.put(ghUrl, {
                  message: `Auto update 9PB ${new Date().toISOString()}`,
                  content: Buffer.from(outputContent, 'utf8').toString('base64'),
                  sha
                }, {
                  headers: { Authorization: `token ${githubToken}`, 'User-Agent': 'github-action' }
                });
                console.log('âœ… GitHub updated successfully');
              } catch (e) {
                console.error('âš ï¸ Failed to update GitHub:', e && e.message ? e.message : e);
              }

              // Upload to Textdb using application/x-www-form-urlencoded
              const textdbUrl = 'https://textdb.online/update/?key=9PB_SHFX';
              try {
                const params = new URLSearchParams({ value: outputContent }).toString();
                const res = await axios.post(textdbUrl, params, {
                  headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
                });
                if (res.data && res.data.status === 1) {
                  console.log('âœ… Textdb uploaded successfully: ' + (res.data.data && res.data.data.url ? res.data.data.url : 'no-url'));
                } else {
                  console.error('âŒ Textdb upload failed:', res.data);
                }
              } catch (err) {
                console.error('âš ï¸ Error uploading to Textdb:', err && err.message ? err.message : err);
              }
            } else {
              console.log('âš ï¸ Dry run enabled â€” YAML generated but not pushed.');
            }
          }

          generate9PB().catch(err => {
            console.error('âŒ Fatal error:', err && err.message ? err.message : err);
            process.exit(1);
          });
          JS

      - name: Upload 9PB artifact
        uses: actions/upload-artifact@v4
        with:
          name: 9PB
          path: 9PB.yml

      - name: Cleanup old artifacts
        uses: actions/github-script@v6
        with:
          script: |
            const artifacts = await github.rest.actions.listArtifactsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            // Filter artifacts named '9PB' and sort by created_at descending (newest first)
            const items = (artifacts.data.artifacts || [])
              .filter(a => a.name === '9PB')
              .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
            // Keep the latest 2, delete the rest
            const toDelete = items.slice(2);
            for (const art of toDelete) {
              await github.rest.actions.deleteArtifact({
                owner: context.repo.owner,
                repo: context.repo.repo,
                artifact_id: art.id
              });
              core.info(`Deleted old artifact id=${art.id} created_at=${art.created_at}`);
            }
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
