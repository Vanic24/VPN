name: Update VPN Subscription (SUB_9PB)

on:
  schedule:
    - cron: "0 */4 * * *"  # Runs every 4 hours
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'If true, only generate YAML locally without pushing'
        required: false
        default: 'false'

jobs:
  update:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repo
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Install dependencies
      run: npm install axios js-yaml

    - name: Run subscription update
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        SUB_9PB: ${{ secrets.SUB_9PB }}
        DRY_RUN: ${{ github.event.inputs.dry_run }}
      run: |
        node <<'EOF'
        const fs = require('fs');
        const path = require('path');
        const yaml = require('js-yaml');
        const axios = require('axios');

        const dryRun = process.env.DRY_RUN === 'true';
        const subUrl = process.env.SUB_9PB;

        // ---------------- Fetch Subscription ----------------
        async function fetchSubscription(url) {
          const res = await axios.get(url, { timeout: 20000 });
          let text = res.data;

          // ðŸ”¹ Exclude first 2 lines if they start with "proxies:" or metadata
          let lines = text.split(/\r?\n/).filter(l => l.trim() !== '');
          if (lines.length > 2 && lines[0].toLowerCase().includes("proxies")) {
            lines = lines.slice(1); // drop "proxies:" header
          }
          if (lines.length > 1 && lines[0].startsWith('- {')) {
            lines = lines.slice(2); // drop first 2 info lines if JSON style
          }
          return lines.join("\n");
        }

        // ---------------- Proxy Parsers ----------------
        function parseVmess(line) {
          try {
            const json = JSON.parse(line);
            return {
              name: json.name || "vmess",
              type: "vmess",
              server: json.server,
              port: json.port,
              uuid: json.uuid,
              alterId: json.alterId || 0,
              cipher: json.cipher || "auto",
              tls: json.tls || false,
              sni: json.sni || undefined,
              network: json.network || undefined,
              "ws-opts": json['ws-opts'] || undefined,
              "grpc-opts": json['grpc-opts'] || undefined,
              udp: json.udp || false
            };
          } catch (e) {
            return null;
          }
        }

        function parseVless(line) {
          try {
            const json = JSON.parse(line);
            return {
              name: json.name || "vless",
              type: "vless",
              server: json.server,
              port: json.port,
              uuid: json.uuid,
              tls: json.tls || false,
              sni: json.sni || undefined,
              network: json.network || undefined,
              "ws-opts": json['ws-opts'] || undefined,
              "grpc-opts": json['grpc-opts'] || undefined,
              udp: json.udp || false
            };
          } catch (e) {
            return null;
          }
        }

        function parseTrojan(line) {
          try {
            const json = JSON.parse(line);
            return {
              name: json.name || "trojan",
              type: "trojan",
              server: json.server,
              port: json.port,
              password: json.password,
              sni: json.sni || undefined,
              "skip-cert-verify": json['skip-cert-verify'] || false,
              udp: json.udp || false
            };
          } catch (e) {
            return null;
          }
        }

        function parseHysteria2(line) {
          try {
            const json = JSON.parse(line);
            return {
              name: json.name || "hysteria2",
              type: "hysteria2",
              server: json.server,
              port: json.port,
              password: json.password,
              sni: json.sni || undefined,
              alpn: json.alpn || undefined,
              obfs: json.obfs || undefined,
              "skip-cert-verify": json['skip-cert-verify'] || false
            };
          } catch (e) {
            return null;
          }
        }

        function parseAnytls(line) {
          try {
            const json = JSON.parse(line);
            return {
              name: json.name || "anytls",
              type: "anytls",
              server: json.server,
              port: json.port,
              password: json.password,
              sni: json.sni || undefined,
              "skip-cert-verify": json['skip-cert-verify'] || false
            };
          } catch (e) {
            return null;
          }
        }

        // ---------------- Parse Subscription ----------------
        function parseProxies(data) {
          const proxies = [];
          const lines = data.split(/\r?\n/).filter(l => l.trim() !== '');
          for (const line of lines) {
            if (line.includes('"type":"vmess"')) {
              const p = parseVmess(line); if (p) proxies.push(p);
            } else if (line.includes('"type":"vless"')) {
              const p = parseVless(line); if (p) proxies.push(p);
            } else if (line.includes('"type":"trojan"')) {
              const p = parseTrojan(line); if (p) proxies.push(p);
            } else if (line.includes('"type":"hysteria2"')) {
              const p = parseHysteria2(line); if (p) proxies.push(p);
            } else if (line.includes('"type":"anytls"')) {
              const p = parseAnytls(line); if (p) proxies.push(p);
            }
          }
          return proxies;
        }

        // ---------------- Main ----------------
        (async () => {
          try {
            console.log("ðŸ” Fetching subscription...");
            const rawData = await fetchSubscription(subUrl);

            console.log("ðŸ“¦ Parsing proxies...");
            const proxies = parseProxies(rawData);
            console.log(`âœ… Got ${proxies.length} proxies`);

            // ---------------- Template Merge ----------------
            const template = fs.readFileSync(path.join(__dirname, 'ClashTemplate.ini'), 'utf-8');

            const proxies_yaml_block = yaml.dump(proxies);
            const proxy_names_block = proxies.map(p => p.name).join('\n');

            const outputContent = template
              .replace('{{PROXIES}}', proxies_yaml_block)
              .replace('{{PROXY_NAMES}}', proxy_names_block);

            fs.writeFileSync('9PB', outputContent);
            fs.writeFileSync('9PB.yml', proxies_yaml_block);

            console.log("ðŸ’¾ Files written: 9PB & 9PB.yml");

            // ---------------- Update Repo ----------------
            if (!dryRun) {
              const repo = process.env.GITHUB_REPOSITORY;
              const token = process.env.GITHUB_TOKEN;
              const apiBase = `https://api.github.com/repos/${repo}/contents/9PB`;

              // get sha
              const current = await axios.get(apiBase, {
                headers: { Authorization: `token ${token}` }
              }).catch(() => null);

              const sha = current?.data?.sha;

              await axios.put(apiBase, {
                message: `Auto update 9PB at ${new Date().toISOString()}`,
                content: Buffer.from(outputContent).toString('base64'),
                sha: sha
              }, { headers: { Authorization: `token ${token}` } });

              console.log("âœ… GitHub updated successfully");
            } else {
              console.log("ðŸš« Dry run mode, not pushing to repo");
            }

              // Upload to Textdb using application/x-www-form-urlencoded
              const textdbUrl = 'https://textdb.online/update/?key=9PB_SHFX';
              try {
                const params = new URLSearchParams({ value: outputContent }).toString();
                const res = await axios.post(textdbUrl, params, {
                  headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
                });
                if (res.data && res.data.status === 1) {
                  console.log('âœ… Textdb uploaded successfully: ' + (res.data.data && res.data.data.url ? res.data.data.url : 'no-url'));
                } else {
                  console.error('âŒ Textdb upload failed:', res.data);
                }
              } catch (err) {
                console.error('âš ï¸ Error uploading to Textdb:', err && err.message ? err.message : err);
              }
            } else {
              console.log('âš ï¸ Dry run enabled â€” YAML generated but not pushed.');
            }
          }

          generate9PB().catch(err => {
            console.error('âŒ Fatal error:', err && err.message ? err.message : err);
            process.exit(1);
          });
          JS

    - name: Upload YAML artifact
      uses: actions/upload-artifact@v4
      with:
        name: 9PB
        path: 9PB.yml

    - name: Cleanup old artifacts
      uses: actions/github-script@v7
      with:
        script: |
          const artifacts = await github.rest.actions.listArtifactsForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            per_page: 100
          });
          const oldArtifacts = artifacts.data.artifacts
            .filter(a => a.name === "9PB")
            .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
            .slice(2);
          for (const artifact of oldArtifacts) {
            await github.rest.actions.deleteArtifact({
              owner: context.repo.owner,
              repo: context.repo.repo,
              artifact_id: artifact.id
            });
            core.info(`ðŸ—‘ Deleted old artifact ${artifact.name} (${artifact.id})`);
          }
