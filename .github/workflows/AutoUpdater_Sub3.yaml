name: Update VPN Subscription (SUB_Sub3)

on:
  schedule:
    - cron: '0 */4 * * *' # every 4 hours
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'If true, only generate YAML locally without pushing'
        required: false
        default: 'false'

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install axios js-yaml

      - name: Run AutoUpdater Script
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SUB_SUB3: ${{ secrets.SUB_SUB3 }}
          DRY_RUN: ${{ github.event.inputs.dry_run }}
        run: |
          node <<'JS'
          const fs = require('fs');
          const path = require('path');
          const axios = require('axios');
          const yaml = require('js-yaml');

          const now = new Date();
          const offsetMinutes = 6.5 * 60; // +6:30 hours
          const localTime = new Date(now.getTime() + offsetMinutes * 60 * 1000);
          const pad = n => n.toString().padStart(2, '0');
          const timestamp = `${pad(localTime.getDate())}.${pad(localTime.getMonth()+1)}.${localTime.getFullYear()} ${pad(localTime.getHours())}:${pad(localTime.getMinutes())}:${pad(localTime.getSeconds())}`;

          const dry_run = process.env.DRY_RUN === 'true';
          const subUrl = process.env.SUB_SUB3;

          const fetchSub = async () => {
            const res = await axios.get(subUrl);
            return Buffer.from(res.data, 'base64').toString();
          };

          // --- Simple raw node parser ---
          function parseRawNode(line) {
            try {
              line = line.trim();
              if (!line) return null;

              let type = '';
              if (line.startsWith('vmess://')) type = 'vmess';
              else if (line.startsWith('vless://')) type = 'vless';
              else if (line.startsWith('ss://')) type = 'ss';
              else if (line.startsWith('trojan://')) type = 'trojan';
              else if (line.startsWith('hysteria2://')) type = 'hysteria2';
              else if (line.startsWith('anytls://')) type = 'anytls';
              else if (line.startsWith('tuic://')) type = 'tuic';
              else type = 'unknown';

              let rawPart = line;
              let name = type;
              if (line.includes('#')) {
                const parts = line.split('#');
                rawPart = parts[0];
                name = decodeURIComponent(parts.slice(1).join('#')) || type;
              }

              return { name, type, raw: rawPart };
            } catch (err) {
              console.error('❌ Failed to parse raw node:', line, err.message);
              return null;
            }
          }

          const generateSub3 = async () => {
            const rawData = await fetchSub();
            const lines = rawData.split('\n').slice(3); // remove first 3 lines if header
            const proxies = [];
            let totalLines = 0, parsedCount = 0, failedCount = 0;

            console.log(`🔗 Subscription source URL: ${subUrl}`);
            console.log(`📥 Raw subscription decoded successfully`);
            console.log(`📄 Total lines after header removed: ${lines.length}`);

            for (let line of lines) {
              line = line.trim();
              if (!line) continue;
              totalLines++;

              const p = parseRawNode(line);
              if (p) {
                proxies.push(p);
                parsedCount++;
              } else {
                failedCount++;
                console.warn(`⚠️ Failed to parse line: ${line}`);
              }
            }

            console.log(`📊 Parsing Summary:`);
            console.log(` • Total lines processed: ${totalLines}`);
            console.log(` • Successfully parsed: ${parsedCount}`);
            console.log(` • Failed to parse: ${failedCount}`);
            console.log(` • Final nodes count: ${proxies.length}`);

            // Load Clash template
            const templatePath = path.join(__dirname, 'ClashTemplate.ini');
            if (!fs.existsSync(templatePath)) {
              console.error('❌ ClashTemplate.ini not found at', templatePath);
              process.exit(1);
            }
            const template = fs.readFileSync(templatePath, 'utf-8');

            // Build YAML blocks
            const proxies_yaml_block = yaml.dump(proxies, { lineWidth: -1 }).trimEnd();
            const proxy_names_block = proxies.map(p => `      - ${p.name}`).join("\n");

            // Replace placeholders
            let outputContent = template.replace(/{{PROXIES}}/g, proxies_yaml_block);
            outputContent = outputContent.replace(/{{PROXY_NAMES}}/g, proxy_names_block);

            const yamlData = `# Last update: ${timestamp}\n` + outputContent;

            fs.writeFileSync('Sub3', outputContent, 'utf8');
            fs.writeFileSync('Sub3.yml', outputContent, 'utf8');
            console.log('✅ Local files written: Sub3, Sub3.yml');

            if (!dry_run) {
              // Update GitHub
              const ghUrl = `https://api.github.com/repos/${process.env.GITHUB_REPOSITORY}/contents/Sub3`;
              const ghRes = await axios.get(ghUrl, { headers: { Authorization: `token ${process.env.GITHUB_TOKEN}` } });
              const sha = ghRes.data.sha;

              await axios.put(ghUrl, {
                message: `🎉Sub3 Auto update successful🎉 - ${timestamp}`,
                content: Buffer.from(outputContent).toString('base64'),
                sha
              }, { headers: { Authorization: `token ${process.env.GITHUB_TOKEN}` } });
              console.log('✅ GitHub updated successfully');

              // TextDB update
              const deleteUrl = 'https://textdb.online/update/?key=Sub3_SHFX&value={}';
              await axios.post(deleteUrl, { value: '' }, { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } });
              console.log('🗑️ Old Textdb record deleted successfully');

              await new Promise(r => setTimeout(r, 3000)); // wait 3s

              const textdbUrl = 'https://textdb.online/update/?key=Sub3_SHFX&value={}';
              const res = await axios.post(textdbUrl, { value: yamlData }, { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } });
              if (res.data.status === 1) console.log('✅ Textdb uploaded successfully: ' + res.data.data.url);
              else console.error('❌ Textdb upload failed:', res.data);
            }
          };

          generateSub3().catch(err => { console.error(err); process.exit(1); });
          JS

      - name: Upload Sub3 artifact
        uses: actions/upload-artifact@v4
        with:
          name: Sub3
          path: Sub3.yml

      - name: Cleanup old artifacts
        uses: actions/github-script@v6
        with:
          script: |
            const artifacts = await github.rest.actions.listArtifactsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            for (const artifact of artifacts.data.artifacts.filter(a => a.name === 'Sub3').slice(2)) {
              await github.rest.actions.deleteArtifact({
                owner: context.repo.owner,
                repo: context.repo.repo,
                artifact_id: artifact.id
              });
            }
