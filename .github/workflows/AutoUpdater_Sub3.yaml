name: Update VPN Subscription (SUB_Sub3)

on:
  schedule:
    - cron: '0 */1 * * *' # every 1 hours
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'If true, only generate YAML locally without pushing'
        required: false
        default: 'false'

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install axios js-yaml

      - name: Run AutoUpdater Script
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SUB_SUB3: ${{ secrets.SUB_SUB3 }}
          DRY_RUN: ${{ github.event.inputs.dry_run }}
        run: |
          node <<'JS'
          const fs = require('fs');
          const path = require('path');
          const axios = require('axios');
          const yaml = require('js-yaml');
          const querystring = require('querystring');

          const now = new Date();
          const offsetMinutes = 6.5 * 60; // +6:30 hours
          const localTime = new Date(now.getTime() + offsetMinutes*60000);
          const pad = n => n.toString().padStart(2,'0');
          const timestamp = `${pad(localTime.getDate())}.${pad(localTime.getMonth()+1)}.${localTime.getFullYear()} ${pad(localTime.getHours())}:${pad(localTime.getMinutes())}:${pad(localTime.getSeconds())}`;
          const dry_run = process.env.DRY_RUN === 'true';
          const subUrl = process.env.SUB_SUB3;

          const fetchSub = async () => {
            const res = await axios.get(subUrl);
            return Buffer.from(res.data, 'base64').toString();
          };

          const safeNumber = (v, fallback=0) => {
            const n = Number(v);
            return Number.isFinite(n) ? n : fallback;
          };

          const decodeName = (line) => {
            if (!line.includes('#')) return '';
            return decodeURIComponent(line.split('#')[1] || '');
          };

          // --- Universal Clash-compatible parser ---
          const parseNode = (line) => {
            try {
              let name = decodeName(line);
              let raw = line.trim();

              if (raw.startsWith('vmess://')) {
                const confJson = Buffer.from(raw.slice(8), 'base64').toString();
                const conf = JSON.parse(confJson);
                const net = (conf.net || 'tcp').toLowerCase();
                return {
                  name: name || conf.ps || 'vmess',
                  type: 'vmess',
                  server: conf.add || '',
                  port: safeNumber(conf.port),
                  uuid: conf.id || '',
                  alterId: safeNumber(conf.aid || conf.alterId || 0),
                  cipher: conf.type || 'auto',
                  network: net,
                  wsPath: conf.path || '',
                  tls: (conf.tls || '').toLowerCase() === 'tls',
                  sni: conf.sni || conf.servername || ''
                };
              }

              if (raw.startsWith('vless://')) {
                const [urlPart] = raw.slice(7).split('#');
                const [base, queryStr] = urlPart.split('?');
                const [uuid, hostPort] = base.split('@');
                const [server, port] = hostPort.split(':');
                const query = {};
                if (queryStr) queryStr.split('&').forEach(p => { const [k,v]=p.split('='); query[k]=decodeURIComponent(v||''); });
                return {
                  name: name || 'vless',
                  type: 'vless',
                  server: server || '',
                  port: safeNumber(port),
                  uuid: uuid || '',
                  network: query.type || 'tcp',
                  tls: query.security==='tls'||query.security==='reality',
                  sni: query.sni||'',
                  flow: query.flow||'',
                  pbk: query.pbk||'',
                  sid: query.sid||'',
                  path: query.path||'',
                  host: query.host||'',
                  quicSecurity: query.quicSecurity||''
                };
              }

              if (raw.startsWith('trojan://')) {
                const [before, after] = raw.slice(9).split('#');
                const u = new URL(`trojan://${before}`);
                const q = Object.fromEntries(u.searchParams.entries());
                const net = q.type || q.transport || 'tcp';
                return {
                  name: name || decodeURIComponent(after || '') || 'trojan',
                  type: 'trojan',
                  server: u.hostname || '',
                  port: safeNumber(u.port || q.port),
                  password: u.username || '',
                  network: net,
                  tls: (q.security||'').toLowerCase()==='tls',
                  sni: q.sni||'',
                  wsPath: q.path||'',
                  grpcServiceName: q.serviceName||q['service-name']||''
                };
              }

              if (raw.startsWith('hysteria2://')) {
                const [urlPart] = raw.slice(11).split('#');
                const [userHostPort, queryStr] = urlPart.split('/?');
                const [password, hostPort] = userHostPort.split('@');
                const [server, port] = hostPort.split(':');
                const query = {};
                if (queryStr) queryStr.split('&').forEach(p=>{const [k,v]=p.split('='); query[k]=v;});
                return {
                  name: name || 'hysteria2',
                  type: 'hysteria2',
                  server: server || '',
                  port: safeNumber(port),
                  'auth-str': decodeURIComponent(password||''),
                  udp: query.udp==='true',
                  insecure: query.insecure==='1' || query.insecure==='true',
                  sni: query.sni||'',
                  'skip-cert-verify': query['skip-cert-verify']==='true'
                };
              }

              if (raw.startsWith('ss://')) {
                const [data] = raw.slice(5).split('#');
                let method, password, server, port;
                if (data.includes('@')) {
                  const [mp, hp] = data.split('@');
                  [method, password] = mp.includes(':')? mp.split(':'):[mp,''];
                  [server, port] = hp.split(':');
                } else {
                  const decoded = Buffer.from(data,'base64').toString('utf8');
                  const [mp, hp] = decoded.split('@');
                  [method, password] = mp.split(':');
                  [server, port] = hp.split(':');
                }
                return {
                  name: name || 'ss',
                  type: 'ss',
                  server: server||'',
                  port: safeNumber(port),
                  cipher: method||'',
                  password: password||''
                };
              }

              if (raw.startsWith('ssr://')) {
                const decoded = Buffer.from(raw.slice(6),'base64').toString('utf8');
                const [main, paramStr] = decoded.split('/?');
                const [server, port, protocol, method, obfs, passwordB64] = main.split(':');
                const params = querystring.parse(paramStr||'');
                return {
                  name: decodeURIComponent(params.remarks||'ssr') || 'ssr',
                  type: 'ssr',
                  server: server||'',
                  port: safeNumber(port),
                  cipher: method||'',
                  protocol: protocol||'',
                  obfs: obfs||'',
                  password: Buffer.from(passwordB64||'','base64').toString('utf8')
                };
              }

              return null;
            } catch (err) {
              console.error('❌ Failed to parse line:', line, err.message);
              return null;
            }
          };

          const generate9PB = async () => {
            console.log(`🔗 Fetching subscription from secret repo: ${subUrl}`);
            const rawData = await fetchSub(subUrl);
            const lines = rawData.split('\n').slice(2); // remove first 2 lines
            console.log(`📥 Total source nodes fetched: ${lines.length}`);

            const proxies = [];
            const failedNodes = [];
            let parsedCount=0, failedCount=0;

            for (let line of lines) {
              line = line.trim();
              if(!line) continue;
              const p = parseNode(line);
              if(p){ proxies.push(p); parsedCount++; }
              else { failedCount++; failedNodes.push(line); }
            }

            console.log(`📊 Parsing Summary:`);
            console.log(` • Total nodes fetched: ${lines.length}`);
            console.log(` • Successfully parsed: ${parsedCount}`);
            console.log(` • Failed to parse: ${failedCount}`);
            if(failedNodes.length) console.log(` • Failed nodes:\n${failedNodes.join('\n')}`);
            console.log(` • Total available nodes: ${proxies.length}`);
            
            const templatePath = path.join(__dirname,'ClashTemplate.ini');
            if(!fs.existsSync(templatePath)){ console.error('❌ ClashTemplate.ini not found'); process.exit(1); }
            const template = fs.readFileSync(templatePath,'utf-8');

            const proxies_yaml_block = yaml.dump(proxies, {lineWidth:-1}).trimEnd();
            const proxy_names_block = proxies.map(p=>`      - ${p.name}`).join("\n");

            let outputContent = template.replace(/{{PROXIES}}/g, proxies_yaml_block);
            outputContent = outputContent.replace(/{{PROXY_NAMES}}/g, proxy_names_block);

            const yamlData = `# Last update: ${timestamp}\n${outputContent}`;
            fs.writeFileSync('9PB', outputContent,'utf8');
            fs.writeFileSync('9PB.yml', outputContent,'utf8');

            if(!dry_run){
              // --- GitHub update ---
              const ghUrl=`https://api.github.com/repos/${process.env.GITHUB_REPOSITORY}/contents/9PB`;
              const ghRes=await axios.get(ghUrl,{headers:{Authorization:`token ${process.env.GITHUB_TOKEN}`}});
              const sha=ghRes.data.sha;
              await axios.put(ghUrl,{message:`🎉9PB Auto update successful🎉 - ${timestamp}`,content:Buffer.from(outputContent).toString('base64'),sha},{headers:{Authorization:`token ${process.env.GITHUB_TOKEN}`}});
              console.log('✅ GitHub updated successfully');

              // --- Delete old record from TextDB first ---
              const deleteUrl = 'https://textdb.online/update/?key=Sub3_SHFX';
              const delRes = await axios.post(
                deleteUrl,
                `value={}`,
                { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }
              );
            
              if (delRes.data.status === 1) {
                console.log('🗑️ Old Textdb record deleted successfully');
              } else {
                console.error('⚠️ Failed to delete old Textdb record:', delRes.data);
              }
            
              // --- Sleep before re-upload ---
              const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));
              await sleep(3000);
            
              // --- Upload new record ---
              const textdbUrl = 'https://textdb.online/update/?key=Sub3_SHFX';
              const res = await axios.post(
                textdbUrl,
                `value=${encodeURIComponent(yamlData)}`,
                { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }
              );
            
              if (res.data.status === 1) {
                console.log('✅ Textdb uploaded successfully: ' + res.data.data.url);
              } else {
                console.error('❌ Textdb upload failed:', res.data);
              }
            }

          generate9PB().catch(err=>{ console.error(err); process.exit(1); });
          JS

      - name: Upload 9PB artifact
        uses: actions/upload-artifact@v4
        with:
          name: 9PB
          path: 9PB.yml

      - name: Cleanup old artifacts
        uses: actions/github-script@v6
        with:
          script: |
            const artifacts = await github.rest.actions.listArtifactsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            for (const artifact of artifacts.data.artifacts.filter(a=>a.name==='9PB').slice(10)){
              await github.rest.actions.deleteArtifact({owner:context.repo.owner,repo:context.repo.repo,artifact_id:artifact.id});
            }
