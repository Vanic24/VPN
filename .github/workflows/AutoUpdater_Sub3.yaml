name: Update VPN Subscription (SUB_Sub3)

on:
  schedule:
    - cron: '0 */4 * * *' # every 4 hours
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'If true, only generate YAML locally without pushing'
        required: false
        default: 'false'

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install axios js-yaml

      - name: Run AutoUpdater Script
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SUB_SUB3: ${{ secrets.SUB_SUB3 }}
          DRY_RUN: ${{ github.event.inputs.dry_run }}
        run: |
          node <<'JS'
          const fs = require('fs');
          const path = require('path');
          const axios = require('axios');
          const yaml = require('js-yaml');
          const now = new Date();
          const offsetMinutes = 6.5 * 60; // +6:30 hours in minutes
          const localTime = new Date(now.getTime() + offsetMinutes * 60 * 1000);
          const pad = (n) => n.toString().padStart(2, '0');
          const timestamp = `${pad(localTime.getDate())}.${pad(localTime.getMonth() + 1)}.${localTime.getFullYear()} ${pad(localTime.getHours())}:${pad(localTime.getMinutes())}:${pad(localTime.getSeconds())}`;
          const dry_run = process.env.DRY_RUN === 'true';
          const subUrl = process.env.SUB_SUB3;
          const fetchSub = async () => {
          const res = await axios.get(subUrl);
            return Buffer.from(res.data, 'base64').toString();
          };

          // --- Advanced parsing functions ---
          function safeNumber(v, fallback = 0) {
            const n = Number(v);
            return Number.isFinite(n) ? n : fallback;
          }

          function b64decode(s) {
            if (!s) return '';
            if (s.length % 4) s += '='.repeat(4 - (s.length % 4));
            return Buffer.from(s, 'base64').toString('utf8');
          }

          function parseVmess(line) {
            try {
              const raw = line.slice(8);
              const confJson = b64decode(raw);
              const conf = JSON.parse(confJson);
              const net = (conf.net || 'tcp').toLowerCase();
              const tls = (conf.tls || '').toLowerCase() === 'tls';

              const proxy = {
                name: conf.ps || 'vmess',
                type: 'vmess',
                server: conf.add || '',
                port: safeNumber(conf.port, 0),
                uuid: conf.id || '',
                alterId: safeNumber(conf.aid || conf.alterId || 0, 0),
                cipher: conf.type || 'auto',
                network: net,
                wsPath: conf.path || '',
                tls: tls,
                sni: conf.sni || (conf.servername || '') || ''
              };

              // ---ws-specific extra fields ---
              if (net === 'ws') {
                proxy.wsPath = conf.path || '';
                
                // keep simple header host field if provided
                if (conf.host) proxy.host = conf.host;
              }

              // grpc hint
              if (net === 'grpc') {
                proxy.grpcServiceName = conf.path || '';
              }

              return proxy;
            } catch (err) {
              return null;
            }
          }

          function parseVless(line) {
            try {
              const [before, after] = line.slice(7).split('#');
              const url = new URL(before);
              const q = Object.fromEntries(url.searchParams.entries());
              const net = (q.type || q.transport || 'tcp').toLowerCase();
              const tls = (q.security || '').toLowerCase() === 'tls';

              const proxy = {
                name: decodeURIComponent(after || '') || 'vless',
                type: 'vless',
                server: url.hostname || '',
                port: safeNumber(url.port || q.port || 0, 0),
                uuid: decodeURIComponent(url.username || '') || '',
                network: net,
                wsPath: q.path || '',
                tls: tls,
                sni: q.sni || ''
              };

              // ws extras
              if (net === 'ws') {
                proxy.wsPath = q.path || '';
                if (q.host) proxy.host = q.host;
              }
              if (net === 'grpc') {
                proxy.grpcServiceName = q.serviceName || q['service-name'] || q.service || '';
              }

              return proxy;
            } catch (err) {
              return null;
            }
          }

          function parseTrojan(line) {
            try {
              const [before, after] = line.slice(9).split('#');
              const url = new URL(`trojan://${before}`);
              const q = Object.fromEntries(url.searchParams.entries());
              const net = (q.type || q.transport || 'tcp').toLowerCase();
              const tls = (q.security || '').toLowerCase() === 'tls';

              const proxy = {
                name: decodeURIComponent(after || '') || 'trojan',
                type: 'trojan',
                server: url.hostname || '',
                port: safeNumber(url.port || q.port || 0, 0),
                password: url.username || '',
                sni: q.sni || '',
                tls: tls,
                network: net
              };

              if (net === 'ws') {
                proxy.wsPath = q.path || '';
                if (q.host) proxy.host = q.host;
              }
              if (net === 'grpc') {
                proxy.grpcServiceName = q.serviceName || q['service-name'] || '';
              }

              return proxy;
            } catch (err) {
              return null;
            }
          }

          function parseHysteria2(line) {
            try {
              const u = new URL(line);
              const name = decodeURIComponent(u.hash ? u.hash.slice(1) : '') || 'hysteria2';
              return {
                name,
                type: 'hysteria2',
                server: u.hostname || '',
                port: safeNumber(u.port || 0, 0),
                password: decodeURIComponent(u.username || '') || '',
                udp: u.searchParams.get('udp') === 'true',
                sni: u.searchParams.get('sni') || '',
                "skip-cert-verify": u.searchParams.get('skip-cert-verify') === 'true'
              };
            } catch (err) {
              return null;
            }
          }

          function parseAnytls(line) {
            try {
              const u = new URL(line);
              const name = decodeURIComponent(u.hash ? u.hash.slice(1) : '') || 'anytls';
              return {
                name,
                type: 'anytls',
                server: u.hostname || '',
                port: safeNumber(u.port || 0, 0),
                password: decodeURIComponent(u.username || '') || '',
                udp: u.searchParams.get('udp') === 'true',
                sni: u.searchParams.get('sni') || '',
                "skip-cert-verify": u.searchParams.get('skip-cert-verify') === 'true'
              };
            } catch (err) {
              return null;
            }
          }

          def parse_tuic(url):
            try:
                parsed = urllib.parse.urlparse(url)
                userinfo, host, port = parsed.netloc.split("@")[0], parsed.hostname, parsed.port
                uuid, pwd = userinfo.split(":")
                params = urllib.parse.parse_qs(parsed.query)
        
                return {
                    "type": "tuic",
                    "server": host,
                    "port": int(port),
                    "uuid": uuid,
                    "password": pwd,
                    "params": {k: v[0] for k, v in params.items()}
                }
            except Exception as e:
                return {"type": "tuic", "error": str(e)}

          function parseSS(line) {
            try {
              // ss://method:password@server:port#name
              const raw = line.slice(5); // remove "ss://"
              const [before, after] = raw.split('#');
              const decoded = b64decode(before.includes('@') ? before.split('@')[0] : before);
              
              let method = '';
              let password = '';
              let server = '';
              let port = 0;
          
              if (before.includes('@')) {
                // format: method:password@server:port
                const [userpass, hostport] = before.split('@');
                [method, password] = b64decode(userpass).split(':');
                const [host, p] = hostport.split(':');
                server = host;
                port = safeNumber(p, 0);
              } else {
                // format already decoded
                const [methodPass, hostport] = decoded.split('@');
                [method, password] = methodPass.split(':');
                const [host, p] = hostport.split(':');
                server = host;
                port = safeNumber(p, 0);
              }
          
              const proxy = {
                name: decodeURIComponent(after || '') || 'shadowsocks',
                type: 'ss',
                server,
                port,
                cipher: method,
                password
              };
          
              return proxy;
            } catch (err) {
              console.error('‚ùå Failed to parse SS node:', line, err.message);
              return null;
            }
          }

          def parse_ssr(url):
            try:
                raw = url[len("ssr://"):]
                decoded = base64.urlsafe_b64decode(raw + "=" * (-len(raw) % 4)).decode()
                parts = decoded.split("/?")
                main = parts[0].split(":")
                host, port, protocol, method, obfs, pwd_enc = main[:6]
                password = base64.urlsafe_b64decode(pwd_enc + "=" * (-len(pwd_enc) % 4)).decode()
        
                params = {}
                if len(parts) > 1:
                    query = urllib.parse.parse_qs(parts[1])
                    for k, v in query.items():
                        try:
                            params[k] = base64.urlsafe_b64decode(v[0] + "=" * (-len(v[0]) % 4)).decode()
                        except:
                            params[k] = v[0]
        
                return {
                    "type": "ssr",
                    "server": host,
                    "port": int(port),
                    "protocol": protocol,
                    "method": method,
                    "obfs": obfs,
                    "password": password,
                    "params": params
                }
            except Exception as e:
                return {"type": "ssr", "error": str(e)}
    
          // --- End advanced parsers ---
          const generateSub3 = async () => {
            const rawData = await fetchSub();
            // preserve original behavior: remove first three info lines
            const lines = rawData.split('\n').slice(3);
            const proxies = [];
            let totalLines = 0, parsedCount = 0, failedCount = 0;
            console.log(`üîó Subscription source URL: ${subUrl}`);
            console.log(`üì• Raw subscription decoded successfully`);
            console.log(`üìÑ Total lines after header removed: ${lines.length}`);

            for (let line of lines) {
              line = line.trim();
              if (!line) continue;
              totalLines++;
              let p = null;

              try {
                if (line.startsWith('vmess://')) {
                  const p = parseVmess(line);
                  if (p) proxies.push(p);
                }
                else if (line.startsWith('vless://')) {
                  const p = parseVless(line);
                  if (p) proxies.push(p);
                }
                else if (line.startsWith('trojan://')) {
                  const p = parseTrojan(line);
                  if (p) proxies.push(p);
                }
                else if (line.startsWith('hysteria2://')) {
                  const p = parseHysteria2(line);
                  if (p) proxies.push(p);
                }
                else if (line.startsWith('anytls://')) {
                  const p = parseAnytls(line);
                  if (p) proxies.push(p);
                }
                else if (line.startsWith('tuic://')) {
                  const p = parseTuic(line);
                  if (p) proxies.push(p);
                }
                else if (line.startsWith('ss://')) {
                  const p = parsess(line);
                  if (p) proxies.push(p);
                }
                else if (line.startsWith('ssr://')) {
                  const p = parsessr(line);
                  if (p) proxies.push(p);
                }
                // keep silent on unsupported lines (like plain YAML blocks or other schemes)
              } catch (err) {
                console.error('Failed to parse line:', line, err);
              }
              if (p) {
                proxies.push(p);
                parsedCount++;
              } else {
                failedCount++;
                console.warn(`‚ö†Ô∏è Failed to parse line: ${line}`);
              }
            }

            console.log(`üìä Parsing Summary:`); console.log(` ‚Ä¢ Total lines processed: ${totalLines}`);
            console.log(` ‚Ä¢ Successfully parsed: ${parsedCount}`);
            console.log(` ‚Ä¢ Failed to parse: ${failedCount}`);
            console.log(` ‚Ä¢ Final nodes count: ${proxies.length}`);

            // Load template
            const templatePath = path.join(__dirname, 'ClashTemplate.ini');
            if (!fs.existsSync(templatePath)) {
              console.error('‚ùå ClashTemplate.ini not found at', templatePath);
              process.exit(1);
            }
            const template = fs.readFileSync(templatePath, 'utf-8');

            // Build YAML blocks
            const proxies_yaml_block = yaml.dump(proxies, { lineWidth: -1 }).trimEnd();
            // Build proxy names block (list)
            const proxy_names_block = proxies.map(p => `      - ${p.name}`).join("\n");

            // Replace placeholders (all occurrences)
            let outputContent = template.replace(/{{PROXIES}}/g, proxies_yaml_block);
            outputContent = outputContent.replace(/{{PROXY_NAMES}}/g, proxy_names_block);

            // Prepare YAML output with timestamp
            const yamlData = `# Last update: ${timestamp}\n` + outputContent;

            // Write output files
            fs.writeFileSync('Sub3', outputContent, 'utf8');
            fs.writeFileSync('Sub3.yml', outputContent, 'utf8');

            console.log('‚úÖ Local files written: Sub, Sub.yml');

            if (!dry_run) {
              // Update GitHub
              const ghUrl = `https://api.github.com/repos/${process.env.GITHUB_REPOSITORY}/contents/Sub3`;
              const ghRes = await axios.get(ghUrl, {
                headers: { Authorization: `token ${process.env.GITHUB_TOKEN}` }
              });
              const sha = ghRes.data.sha;

              await axios.put(ghUrl, {
                message: `üéâSub3 Auto update successfulüéâ - ${timestamp}`,
                content: Buffer.from(outputContent).toString('base64'),
                sha
              }, {
                headers: { Authorization: `token ${process.env.GITHUB_TOKEN}` }
              });
              console.log('‚úÖ GitHub updated successfully');

              // Delete old record from TextDB first
              const deleteUrl = 'https://textdb.online/update/?key=Sub3_SHFX&value={}';

              const delRes = await axios.post(
                deleteUrl,
                { value: '' },
                { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }
              );

              if (delRes.data.status === 1) {
                console.log('üóëÔ∏è Old Textdb record deleted successfully');
              } else {
                console.error('‚ö†Ô∏è Failed to delete old Textdb record:', delRes.data);
              }

              // Simple sleep function
              const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

              // Wait 3 seconds before uploading new data
              await sleep(3000);

              // Update Textdb using POST
              const textdbUrl = 'https://textdb.online/update/?key=Sub3_SHFX&value={}';

              const res = await axios.post(
                textdbUrl,
                { value: yamlData },
                { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }
              );

              if (res.data.status === 1) {
                console.log('‚úÖ Textdb uploaded successfully: ' + res.data.data.url);
              } else {
                console.error('‚ùå Textdb upload failed:', res.data);
              }
            }
          };

          generateSub3().catch(err => {
            console.error(err);
            process.exit(1);
          });
          JS

      - name: Upload Sub3 artifact
        uses: actions/upload-artifact@v4
        with:
          name: Sub3
          path: Sub3.yml

      - name: Cleanup old artifacts
        uses: actions/github-script@v6
        with:
          script: |
            const artifacts = await github.rest.actions.listArtifactsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            for (const artifact of artifacts.data.artifacts.filter(a => a.name === 'Sub3').slice(2)) {
              await github.rest.actions.deleteArtifact({
                owner: context.repo.owner,
                repo: context.repo.repo,
                artifact_id: artifact.id
              });
            }
