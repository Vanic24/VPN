name: Update VPN Subscription (SUB_Sub3)

on:
  schedule:
    - cron: "0 */4 * * *" #Runs every 4 hours
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'If true, only generate YAML locally without pushing'
        required: false
        default: 'false'

jobs:
  update:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repo
      uses: actions/checkout@v3

    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: "20"

    - name: Install dependencies
      run: npm install axios js-yaml

    - name: Generate Clash YAML
      id: generate_yaml
      run: |
        node <<'EOF'
        const axios = require('axios');
        const yaml = require('js-yaml');
        const fs = require('fs');
        const { URL } = require('url');

        const SUB_URL = process.env.SUB_Sub3; // Clash-compatible subscription URL
        const GH_TOKEN = process.env.GH_TOKEN;
        const GITHUB_FILE = "Sub3";
        const dryRun = process.env.DRY_RUN === "true";

        function parseLine(line) {
          const l = line.trim().toLowerCase();
          try {
            if(l.startsWith("vmess://")) {
              const conf = JSON.parse(Buffer.from(line.slice(8), 'base64').toString('utf8'));
              return { name: conf.ps||'vmess', type:'vmess', server:conf.add, port:Number(conf.port), uuid:conf.id, alterId:Number(conf.aid||0), cipher:conf.type||'auto', tls:(conf.tls||'').toLowerCase()==='tls', network:(conf.net||'tcp') };
            }
            else if(l.startsWith("vless://")) {
              const u = new URL(line);
              const q = Object.fromEntries(u.searchParams.entries());
              return { name:u.hash.slice(1)||'vless', type:'vless', server:u.hostname, port:Number(u.port||443), uuid:u.username, tls:(q.security||'').toLowerCase()==='tls', network:(q.type||q.transport||'tcp') };
            }
            else if(l.startsWith("trojan://")) {
              const u = new URL(line);
              const q = Object.fromEntries(u.searchParams.entries());
              return { name:u.hash.slice(1)||'trojan', type:'trojan', server:u.hostname, port:Number(u.port||443), password:u.username, tls:(q.security||'').toLowerCase()==='tls', network:(q.type||q.transport||'tcp') };
            }
            else if(l.startsWith("hysteria2://")) {
              const u = new URL(line);
              return { name:u.hash.slice(1)||'hysteria2', type:'hysteria2', server:u.hostname, port:Number(u.port), password:u.username, udp:u.searchParams.get('udp')==='true', sni:u.searchParams.get('sni'), 'skip-cert-verify':u.searchParams.get('skip-cert-verify')==='true' };
            }
            else if(l.startsWith("anytls://")) {
              const u = new URL(line);
              return { name:u.hash.slice(1)||'anytls', type:'anytls', server:u.hostname, port:Number(u.port), password:u.username, udp:u.searchParams.get('udp')==='true', sni:u.searchParams.get('sni'), 'skip-cert-verify':u.searchParams.get('skip-cert-verify')==='true' };
            }
          } catch(e){ console.log("‚ö†Ô∏è Failed to parse line:", line); }
          return null;
        }

        async function main() {
          const res = await axios.get(SUB_URL, { responseType:'text' });
          let lines = Buffer.from(res.data.trim(), 'base64').toString('utf8')
                        .split(/\r?\n/)
                        .map(l=>l.trim())
                        .filter(Boolean)
                        .slice(3); // remove first 3 info nodes

          const proxies = [];
          for(let line of lines){
            const parsed = parseLine(line);
            if(parsed) proxies.push(parsed);
          }

          console.log(`üîπ Total proxies parsed: ${proxies.length}`);
          console.log("Proxy names:", proxies.map(p=>p.name).join(", "));

          const clashConfig = {
            proxies,
            "proxy-groups":[{ name:"Auto", type:"url-test", proxies: proxies.map(p=>p.name), url:"http://www.gstatic.com/generate_204", interval:300 }],
            rules:["MATCH,Auto"]
          };

          const yamlData = yaml.dump(clashConfig, { noRefs:true, forceQuotes:false, lineWidth:120 });
          fs.writeFileSync(GITHUB_FILE, yamlData, 'utf8');

          if(!dryRun){
            try{
              const fileInfo = await axios.get(`https://api.github.com/repos/Vanic24/VPN/contents/${GITHUB_FILE}`, { headers:{Authorization:`token ${GH_TOKEN}`}});
              await axios.put(`https://api.github.com/repos/Vanic24/VPN/contents/${GITHUB_FILE}`, {
                message:"Auto update Clash YAML Sub3",
                content: Buffer.from(yamlData).toString('base64'),
                sha:fileInfo.data.sha
              }, { headers:{Authorization:`token ${GH_TOKEN}`}});
              console.log("‚úÖ GitHub updated successfully");
            }catch(e){ console.error("‚ö†Ô∏è Failed to update GitHub:", e.message);}
          }else{
            console.log("‚ö†Ô∏è Dry run ‚Äî YAML generated but not pushed.");
          }
        }

        main().catch(e=>{console.error("‚ùå Error:",e); process.exit(1);});
        EOF

      env:
        GH_TOKEN: ${{ secrets.GH_TOKEN }}
        SUB_Sub3: ${{ secrets.SUB_Sub3 }}
        DRY_RUN: ${{ github.event.inputs.dry_run }}

    - name: Upload Clash YAML artifact
      uses: actions/upload-artifact@v4
      with:
        name: Sub3
        path: Sub3.yml

    - name: Delete old artifacts (keep latest Sub3 only)
      run: |
        echo "üîç Checking for old artifacts..."
        artifact_ids=$(gh api repos/${{ github.repository }}/actions/artifacts --jq '.artifacts[] | select(.name=="Sub3") | .id')
        keep_id=$(echo "$artifact_ids" | head -n 1)
        delete_ids=$(echo "$artifact_ids" | tail -n +2)
        if [ -z "$delete_ids" ]; then echo "‚úÖ No old artifacts to delete."; else for id in $delete_ids; do gh api --method DELETE repos/${{ github.repository }}/actions/artifacts/$id; echo "üóë Deleted old artifact $id"; done; fi
      env:
        GH_TOKEN: ${{ secrets.GH_TOKEN }}
