name: Update VPN Subscription (SUB_Sub3)

on:
  schedule:
    - cron: "0 */4 * * *"
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'If true, only generate YAML locally without pushing'
        required: false
        default: 'false'

jobs:
  update:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repo
      uses: actions/checkout@v3

    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: "20"

    - name: Install dependencies
      run: npm install axios js-yaml

    - name: Run update script
      id: generate_yaml
      run: |
        node <<'EOF'
        const axios = require('axios');
        const yaml = require('js-yaml');
        const fs = require('fs');
        const path = require('path');
        const { URL } = require('url');

        const SUB_URL = process.env.SUB_Sub3;
        const GH_TOKEN = process.env.GH_TOKEN;
        const GITHUB_FILE = "Sub3";
        const dryRun = process.env.DRY_RUN === "true";

        function b64decode(s) {
          if (s.length % 4) s += "=".repeat(4 - (s.length % 4));
          return Buffer.from(s, 'base64').toString('utf8');
        }

        function parseVmess(link) { try { const conf = JSON.parse(b64decode(link.slice(8))); return { name: conf.ps||'vmess', type:'vmess', server:conf.add, port:Number(conf.port), uuid:conf.id, alterId:Number(conf.aid||0), cipher:conf.type||'auto', tls: (conf.tls||'').toLowerCase()==='tls', network:(conf.net||'tcp').toLowerCase() }; } catch{return null;} }
        function parseVless(link) { try { const u=new URL(link); const q=Object.fromEntries(u.searchParams.entries()); return { name: decodeURIComponent(u.hash.slice(1))||'vless', type:'vless', server:u.hostname, port:Number(u.port||443), uuid:decodeURIComponent(u.username), tls:(q.security||'').toLowerCase()==='tls', network:(q.type||q.transport||'tcp').toLowerCase() }; } catch{return null;} }
        function parseTrojan(link) { try { const u=new URL(link); const q=Object.fromEntries(u.searchParams.entries()); return { name: decodeURIComponent(u.hash.slice(1))||'trojan', type:'trojan', server:u.hostname, port:Number(u.port||443), password:decodeURIComponent(u.username), tls:(q.security||'').toLowerCase()==='tls', network:(q.type||q.transport||'tcp').toLowerCase() }; } catch{return null;} }
        function parseHysteria2(link) { try { const u=new URL(link); return { name: decodeURIComponent(u.hash.slice(1))||'hysteria2', type:'hysteria2', server:u.hostname, port:Number(u.port), password:decodeURIComponent(u.username), udp:u.searchParams.get('udp')==='true', sni:u.searchParams.get('sni')||undefined, 'skip-cert-verify': u.searchParams.get('skip-cert-verify')==='true' }; } catch{return null;} }
        function parseAnytls(link) { try { const u=new URL(link); return { name: decodeURIComponent(u.hash.slice(1))||'anytls', type:'anytls', server:u.hostname, port:Number(u.port), password:decodeURIComponent(u.username), udp:u.searchParams.get('udp')==='true', sni:u.searchParams.get('sni')||undefined, 'skip-cert-verify': u.searchParams.get('skip-cert-verify')==='true' }; } catch{return null;} }

        async function main() {
          const res = await axios.get(SUB_URL, { responseType: 'text' });
          let lines = b64decode(res.data.trim())
                        .split(/\r?\n/)
                        .map(l => l.trim())
                        .filter(Boolean)
                        .slice(3); // remove first 3 info nodes

          const proxies = [];
          for (let line of lines) {
            const lowerLine = line.trim().toLowerCase();
            let parsed = null;
            if (lowerLine.startsWith("vmess://")) parsed = parseVmess(line);
            else if (lowerLine.startsWith("vless://")) parsed = parseVless(line);
            else if (lowerLine.startsWith("trojan://")) parsed = parseTrojan(line);
            else if (lowerLine.startsWith("hysteria2://")) parsed = parseHysteria2(line);
            else if (lowerLine.startsWith("anytls://")) parsed = parseAnytls(line);
            if (parsed) proxies.push(parsed);
            else console.log("‚ö†Ô∏è Unknown line skipped:", line);
          }

          console.log(`üîπ Total proxies parsed: ${proxies.length}`);
          console.log("Proxy names:", proxies.map(p=>p.name).join(", "));

          const clashConfig = {
            proxies,
            "proxy-groups":[{ name:"Auto", type:"url-test", proxies: proxies.map(p=>p.name), url:"http://www.gstatic.com/generate_204", interval:300 }],
            rules:["MATCH,Auto"]
          };

          const yamlData = yaml.dump(clashConfig, { noRefs:true, forceQuotes:false, lineWidth:120 });
          fs.writeFileSync(GITHUB_FILE, yamlData, "utf8");
          fs.writeFileSync(path.join(process.cwd(),"Sub3.yml"), yamlData, "utf8");

          if (!dryRun) {
            try {
              const fileInfo = await axios.get(`https://api.github.com/repos/Vanic24/VPN/contents/${GITHUB_FILE}`, { headers:{ Authorization:`token ${GH_TOKEN}` } });
              await axios.put(`https://api.github.com/repos/Vanic24/VPN/contents/${GITHUB_FILE}`, { message:"Auto update Clash YAML Sub3", content: Buffer.from(yamlData).toString('base64'), sha:fileInfo.data.sha }, { headers:{ Authorization:`token ${GH_TOKEN}` } });
              console.log("‚úÖ GitHub updated successfully");
            } catch(e){ console.error("‚ö†Ô∏è Failed to update GitHub:", e.message); }
          } else { console.log("‚ö†Ô∏è Dry run enabled ‚Äî YAML generated but not pushed."); }
        }

        main().catch(e=>{console.error("‚ùå Error:",e); process.exit(1);});
        EOF

      env:
        GH_TOKEN: ${{ secrets.GH_TOKEN }}
        SUB_Sub3: ${{ secrets.SUB_Sub3 }}
        DRY_RUN: ${{ github.event.inputs.dry_run }}

    - name: Upload Clash YAML artifact
      uses: actions/upload-artifact@v4
      with:
        name: Sub3
        path: Sub3.yml

    - name: Delete old artifacts (keep latest Sub3 only)
      run: |
        echo "üîç Checking for old artifacts..."
        artifact_ids=$(gh api repos/${{ github.repository }}/actions/artifacts --jq '.artifacts[] | select(.name=="Sub3") | .id')
        keep_id=$(echo "$artifact_ids" | head -n 1)
        delete_ids=$(echo "$artifact_ids" | tail -n +2)
        if [ -z "$delete_ids" ]; then echo "‚úÖ No old artifacts to delete."; else for id in $delete_ids; do gh api --method DELETE repos/${{ github.repository }}/actions/artifacts/$id; echo "üóë Deleted old artifact $id"; done; fi
      env:
        GH_TOKEN: ${{ secrets.GH_TOKEN }}
