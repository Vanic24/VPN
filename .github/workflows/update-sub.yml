name: Update Multiple VPN Subscriptions (Clash YAML + Dry Run + Artifact)

on:
  schedule:
    - cron: "0 */6 * * *"  # Runs every 6 hours
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'If true, only generate YAML locally without pushing'
        required: false
        default: 'false'

jobs:
  update:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repo
      uses: actions/checkout@v3

    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: "20"

    - name: Install dependencies
      run: npm install axios js-yaml

    - name: Run update script
      id: generate_yaml
      run: |
        node <<'EOF'
        const axios = require('axios');
        const yaml = require('js-yaml');
        const fs = require('fs');
        const path = require('path');

        const GH_TOKEN = process.env.GH_TOKEN;
        const dryRun = process.env.DRY_RUN === "true";

        function b64decode(s) {
          if (s.length % 4) s += "=".repeat(4 - (s.length % 4));
          return Buffer.from(s, 'base64').toString('utf8');
        }

        function parseVmess(link) {
          try {
            const conf = JSON.parse(b64decode(link.slice(8)));
            const net = (conf.net || "tcp").toLowerCase();
            const tls = (conf.tls || "").toLowerCase() === "tls";
            const proxy = {
              name: conf.ps || "vmess",
              type: "vmess",
              server: conf.add,
              port: Number(conf.port),
              uuid: conf.id,
              alterId: Number(conf.aid || 0),
              cipher: conf.type || "auto",
              tls,
              network: net,
            };
            if (net === "ws") proxy["ws-opts"] = { path: conf.path || "", headers: { Host: conf.host || "" } };
            if (net === "grpc") proxy["grpc-opts"] = { "grpc-service-name": conf.path || "" };
            if (conf.sni) proxy.servername = conf.sni;
            return proxy;
          } catch { return null; }
        }

        function parseVless(link) {
          try {
            const u = new URL(link);
            const q = Object.fromEntries(u.searchParams.entries());
            const net = (q.type || q.transport || "tcp").toLowerCase();
            const tls = (q.security || "").toLowerCase() === "tls";
            const proxy = {
              name: decodeURIComponent(u.hash.slice(1)) || "vless",
              type: "vless",
              server: u.hostname,
              port: Number(u.port || 443),
              uuid: decodeURIComponent(u.username),
              tls,
              network: net
            };
            if (net === "ws") proxy["ws-opts"] = { path: q.path || "", headers: { Host: q.host || "" } };
            if (net === "grpc") proxy["grpc-opts"] = { "grpc-service-name": q.serviceName || q["service-name"] || "" };
            return proxy;
          } catch { return null; }
        }

        function parseTrojan(link) {
          try {
            const u = new URL(link);
            const q = Object.fromEntries(u.searchParams.entries());
            const net = (q.type || q.transport || "tcp").toLowerCase();
            const tls = (q.security || "").toLowerCase() === "tls";
            const proxy = {
              name: decodeURIComponent(u.hash.slice(1)) || "trojan",
              type: "trojan",
              server: u.hostname,
              port: Number(u.port || 443),
              password: decodeURIComponent(u.username),
              tls,
              network: net
            };
            if (net === "ws") proxy["ws-opts"] = { path: q.path || "", headers: { Host: q.host || "" } };
            if (net === "grpc") proxy["grpc-opts"] = { "grpc-service-name": q.serviceName || q["service-name"] || "" };
            return proxy;
          } catch { return null; }
        }

        const subscriptions = [
          { url: process.env.SUB_URL_1, file: "9PB", push: true, skip: 2 },
          { url: process.env.SUB_URL_2, file: "Sub3", push: true, skip: 0 },
          { url: process.env.SUB_URL_3, file: "Future", push: false, skip: 0 }
        ];

        for (const sub of subscriptions) {
          (async () => {
            try {
              const res = await axios.get(sub.url, { responseType: 'text' });
              let lines = b64decode(res.data.trim()).split(/\r?\n/).slice(sub.skip).filter(Boolean);

              const proxies = [];
              for (const line of lines) {
                if (line.startsWith("vmess://")) proxies.push(parseVmess(line));
                else if (line.startsWith("vless://")) proxies.push(parseVless(line));
                else if (line.startsWith("trojan://")) proxies.push(parseTrojan(line));
              }

              console.log(`üîπ ${sub.file}: Total proxies parsed: ${proxies.length}`);

              const clashConfig = {
                proxies,
                "proxy-groups": [
                  { name: "Auto", type: "url-test", proxies: proxies.map(p=>p.name), url: "http://www.gstatic.com/generate_204", interval: 300 }
                ],
                rules: ["MATCH,Auto"]
              };

              const yamlData = require('js-yaml').dump(clashConfig, { noRefs: true, forceQuotes: false, lineWidth: 120 });
              fs.writeFileSync(sub.file, yamlData, "utf8");
              fs.writeFileSync(path.join(process.cwd(), `${sub.file}.yml`), yamlData, "utf8"); // artifact

              if (!dryRun && sub.push) {
                try {
                  const fileInfo = await axios.get(
                    `https://api.github.com/repos/Vanic24/VPN/contents/${sub.file}`,
                    { headers: { Authorization: `token ${GH_TOKEN}` } }
                  );
                  await axios.put(
                    `https://api.github.com/repos/Vanic24/VPN/contents/${sub.file}`,
                    { message: `Auto update ${sub.file}`, content: Buffer.from(yamlData).toString('base64'), sha: fileInfo.data.sha },
                    { headers: { Authorization: `token ${GH_TOKEN}` } }
                  );
                  console.log(`‚úÖ ${sub.file} updated on GitHub`);
                } catch (e) {
                  console.error(`‚ö†Ô∏è Failed to update ${sub.file} on GitHub:`, e.message);
                }
              } else if (dryRun || !sub.push) {
                console.log(`‚ö†Ô∏è Dry run or future file ‚Äî ${sub.file} generated but not pushed.`);
              }
            } catch (e) {
              console.error(`‚ö†Ô∏è Failed processing ${sub.file}:`, e.message);
            }
          })();
        }
        EOF

      env:
        GH_TOKEN: ${{ secrets.GH_TOKEN }}
        SUB_URL_1: ${{ secrets.SUB_URL_1 }}
        SUB_URL_2: ${{ secrets.SUB_URL_2 }}
        SUB_URL_3: ${{ secrets.SUB_URL_3 }}
        DRY_RUN: ${{ github.event.inputs.dry_run }}

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: VPN_YAMLs
        path: |
          9PB.yml
          Sub3.yml
          Future.yml
