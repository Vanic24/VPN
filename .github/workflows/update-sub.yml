name: Update VPN Subscription (Clash YAML + igdux + Cleanup)

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'If true, only generate YAML locally without pushing'
        required: false
        default: 'false'
  schedule:
    - cron: '0 */6 * * *' # Every 6 hours

permissions:
  contents: write
  actions: write

jobs:
  update:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install puppeteer axios js-base64 js-yaml

      - name: Fetch & convert subscription to Clash YAML
        env:
          SUB_URL: ${{ secrets.SUB_URL }}
        run: |
          node <<'EOF'
          const axios = require('axios');
          const { Base64 } = require('js-base64');
          const yaml = require('js-yaml');
          const fs = require('fs');

          const SUB_URL = process.env.SUB_URL;
          if (!SUB_URL) { console.error("Missing SUB_URL secret"); process.exit(1); }

          const b64decode = (s) => {
            const pad = s.length % 4 ? 4 - (s.length % 4) : 0;
            if (pad) s += '='.repeat(pad);
            return Buffer.from(s, 'base64').toString('utf8');
          };

          function parseVmess(link) {
            try {
              const json = JSON.parse(b64decode(link.slice(8)));
              const net = (json.net || 'tcp').toLowerCase();
              const p = {
                name: json.ps || 'vmess',
                type: 'vmess',
                server: json.add,
                port: Number(json.port),
                uuid: json.id,
                alterId: Number(json.aid || 0),
                cipher: 'auto',
                tls: (json.tls || '').toLowerCase() === 'tls',
                network: net
              };
              if (json.sni) p.servername = json.sni;
              if (net === 'ws') p['ws-opts'] = { path: json.path || '', headers: { Host: json.host || '' } };
              if (net === 'grpc') p['grpc-opts'] = { 'grpc-service-name': json.path || '' };
              return p;
            } catch { return null; }
          }

          (async () => {
            console.log('üì• Fetching subscription...');
            const res = await axios.get(SUB_URL, { responseType: 'text' });
            let decoded;
            try { decoded = Base64.decode(res.data.trim()); } 
            catch { decoded = Buffer.from(res.data.trim(), 'base64').toString('utf8'); }
            let lines = decoded.split(/\r?\n/).map(s => s.trim()).filter(Boolean);

            // Remove first two nodes
            lines = lines.slice(2);

            const proxies = lines.map(line => {
              if (line.startsWith('vmess://')) return parseVmess(line);
              return null;
            }).filter(Boolean);

            console.log(`üîπ Total proxies parsed: ${proxies.length}`);

            const clashConfig = {
              proxies: proxies,
              'proxy-groups': [
                { name: 'Auto', type: 'url-test', proxies: proxies.map(p=>p.name), url: 'http://www.gstatic.com/generate_204', interval: 300 }
              ],
              rules: ['MATCH,Auto']
            };

            const yamlData = yaml.dump(clashConfig, { noRefs: true, lineWidth: 120 });
            fs.writeFileSync('9PB', yamlData, 'utf8');
            console.log('‚úÖ YAML written to ./9PB');
          })().catch(e => { console.error('‚ùå Fatal:', e.message); process.exit(1); });
          EOF

      - name: Dry run check
        if: ${{ github.event.inputs.dry_run == 'true' }}
        run: echo "Dry run: Skipping uploads"

      - name: Commit & push 9PB to GitHub
        if: ${{ github.event.inputs.dry_run != 'true' }}
        run: |
          if git diff --quiet --exit-code 9PB; then
            echo "No changes to 9PB; skipping commit."
          else
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add 9PB
            git commit -m "Auto update Clash YAML (9PB)"
            git push
          fi

      - name: Update igdux via Puppeteer (headless Chrome)
        if: ${{ github.event.inputs.dry_run != 'true' }}
        env:
          IGDUX_EDIT_URL: ${{ secrets.IGDUX_EDIT_URL }}
        run: |
          node <<'EOF'
          const puppeteer = require('puppeteer');
          const fs = require('fs');

          (async () => {
            const url = process.env.IGDUX_EDIT_URL;
            if (!url) { console.error('Missing IGDUX_EDIT_URL secret'); process.exit(1); }

            const content = fs.readFileSync('9PB', 'utf8');
            const browser = await puppeteer.launch({ headless: 'new', args: ['--no-sandbox'] });
            const page = await browser.newPage();

            await page.setExtraHTTPHeaders({ 'Accept': '*/*','Accept-Language': 'en-US,en;q=0.9' });

            console.log('üåê Opening igdux editor...');
            await page.goto(url, { waitUntil: 'networkidle2', timeout: 60000 });

            const selector = 'textarea, [contenteditable="true"], #editor, #app textarea';
            await page.waitForSelector(selector, { timeout: 30000 });

            const isContentEditable = await page.$eval(selector, el => el.getAttribute && el.getAttribute('contenteditable') === 'true');

            if (isContentEditable) {
              await page.$eval(selector, (el, txt) => { el.innerText = txt; }, content);
            } else {
              await page.$eval(selector, (el, txt) => { el.value = txt; el.dispatchEvent(new Event('input', { bubbles: true })); }, content);
            }

            console.log('üíæ Attempting to save...');

            async function tryXPathClick(xpath) {
              const handles = await page.$x(xpath);
              if (handles.length > 0) { await handles[0].click(); return true; }
              return false;
            }

            let saved = false;
            const attempts = [
              "//button[contains(., 'Save')]",
              "//button[contains(., '‰øùÂ≠ò')]",
              "//button[contains(., 'submit')]",
              "//input[@type='submit']",
              "//button[@type='submit']",
              "//button[contains(@class,'save')]"
            ];

            for (const xp of attempts) {
              if (await tryXPathClick(xp)) { saved = true; break; }
            }

            if (!saved) {
              const key = process.platform === 'darwin' ? 'Meta' : 'Control';
              await page.keyboard.down(key);
              await page.keyboard.press('KeyS');
              await page.keyboard.up(key);
            }

            await page.waitForTimeout(3000);
            console.log('‚úÖ igdux update complete');
            await browser.close();
          })().catch(e => { console.error('‚ùå Puppeteer error:', e.message); process.exit(1); });
          EOF

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: 9PB
          path: 9PB
          retention-days: 1

            - name: Delete old artifacts
        uses: actions/github-script@v7
        with:
          script: |
            const all = await github.rest.actions.listArtifactsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });
            const targets = all.data.artifacts
              .filter(a => a.name==='9PB' && !a.expired)
              .sort((a,b)=>new Date(b.created_at)-new Date(a.created_at));
            for(const [i,art] of targets.entries()) {
              if(i===0) continue;
              await github.rest.actions.deleteArtifact({
                owner: context.repo.owner,
                repo: context.repo.repo,
                artifact_id: art.id
              });
              core.info(`üóë Deleted old artifact ${art.id}`);
            }

      - name: Delete old workflow runs (keep latest)
        uses: actions/github-script@v7
        with:
          script: |
            const runs = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: context.workflow,
              per_page: 50
            });
            const sorted = runs.data.workflow_runs
              .sort((a,b)=>new Date(b.created_at)-new Date(a.created_at));
            for(const [i,run] of sorted.entries()) {
              if(i===0 || run.id===context.runId) continue;
              try {
                await github.rest.actions.deleteWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: run.id
                });
                core.info(`üóë Deleted old run ${run.id}`);
              } catch(e){
                core.warning(`Could not delete run ${run.id}: ${e.message}`);
              }
            }
