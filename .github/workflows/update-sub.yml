name: Update VPN Subscription (Clash YAML + Dry Run + Artifact + Cleanup)

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'If true, only generate YAML locally without pushing'
        required: false
        default: 'false'
  schedule:
    - cron: '0 */6 * * *' # every 6 hours

permissions:
  contents: write
  actions: write

jobs:
  update:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install axios js-base64 yaml

      - name: Fetch, convert, and update
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
          SUB_URL: ${{ secrets.SUB_URL }}
          IGDUX_EDIT_URL: ${{ secrets.IGDUX_EDIT_URL }}
          DRY_RUN: ${{ github.event.inputs.dry_run }}
        run: |
          node <<'EOF'
          const axios = require('axios');
          const { Base64 } = require('js-base64');
          const yaml = require('yaml');
          const fs = require('fs');

          const GH_TOKEN = process.env.GH_TOKEN;
          const SUB_URL = process.env.SUB_URL;
          const IGDUX_EDIT_URL = process.env.IGDUX_EDIT_URL;
          const GITHUB_FILE = "9PB";
          const dryRun = process.env.DRY_RUN === "true";

          // ---- Parsers ----
          function parseVmess(url) {
            try {
              const decoded = JSON.parse(Base64.decode(url.replace("vmess://", "")));
              const net = (decoded.net || "tcp").toLowerCase();
              const p = {
                name: decoded.ps || "vmess",
                type: "vmess",
                server: decoded.add,
                port: Number(decoded.port),
                uuid: decoded.id,
                alterId: Number(decoded.aid || 0),
                cipher: "auto",
                tls: (decoded.tls || "").toLowerCase() === "tls",
                network: net,
              };
              if (decoded.sni) p.servername = decoded.sni;
              if (net === "ws") p["ws-opts"] = { path: decoded.path || "", headers: { Host: decoded.host || "" } };
              if (net === "grpc") p["grpc-opts"] = { "grpc-service-name": decoded.path || "" };
              return p;
            } catch { return null; }
          }

          function parseVless(url) {
            try {
              const u = new URL(url);
              const q = Object.fromEntries(u.searchParams.entries());
              const net = (q.type || q.transport || "tcp").toLowerCase();
              const p = {
                name: decodeURIComponent(u.hash.slice(1)) || "vless",
                type: "vless",
                server: u.hostname,
                port: Number(u.port || 443),
                uuid: decodeURIComponent(u.username),
                tls: (q.security || "").toLowerCase() === "tls",
                network: net
              };
              if (q.sni) p.servername = q.sni;
              if (net === "ws") p["ws-opts"] = { path: q.path || "", headers: { Host: q.host || "" } };
              if (net === "grpc") p["grpc-opts"] = { "grpc-service-name": q.serviceName || q["service-name"] || "" };
              return p;
            } catch { return null; }
          }

          function parseTrojan(url) {
            try {
              const u = new URL(url);
              const q = Object.fromEntries(u.searchParams.entries());
              const net = (q.type || q.transport || "tcp").toLowerCase();
              const p = {
                name: decodeURIComponent(u.hash.slice(1)) || "trojan",
                type: "trojan",
                server: u.hostname,
                port: Number(u.port || 443),
                password: decodeURIComponent(u.username),
                tls: (q.security || "tls").toLowerCase() === "tls", // trojan usually with tls
                network: net
              };
              if (q.sni) p.sni = q.sni;
              if (net === "ws") p["ws-opts"] = { path: q.path || "", headers: { Host: q.host || "" } };
              if (net === "grpc") p["grpc-opts"] = { "grpc-service-name": q.serviceName || q["service-name"] || "" };
              return p;
            } catch { return null; }
          }

          (async () => {
            try {
              console.log("üì• Fetching subscription...");
              const res = await axios.get(SUB_URL, { responseType: 'text' });
              let decoded;
              try {
                decoded = Base64.decode(res.data.trim());
              } catch (e) {
                throw new Error("Subscription was not valid Base64 or was empty.");
              }

              let lines = decoded.split(/\r?\n/).map(s => s.trim()).filter(Boolean);

              // Remove first two non-proxy lines per your requirement
              lines = lines.slice(2);

              const proxies = [];
              for (const line of lines) {
                if (line.startsWith("vmess://")) proxies.push(parseVmess(line));
                else if (line.startsWith("vless://")) proxies.push(parseVless(line));
                else if (line.startsWith("trojan://")) proxies.push(parseTrojan(line));
              }
              const valid = proxies.filter(Boolean);
              console.log(`üîπ Total proxies parsed: ${valid.length}`);

              // Minimal Clash YAML compatible with FlClash
              const clashConfig = {
                proxies: valid,
                "proxy-groups": [
                  {
                    name: "Auto",
                    type: "url-test",
                    proxies: valid.map(p => p.name),
                    url: "http://www.gstatic.com/generate_204",
                    interval: 300
                  }
                ],
                rules: ["MATCH,Auto"]
              };

              const yamlData = yaml.stringify(clashConfig);

              // Save as repo file name and as artifact
              fs.writeFileSync("9PB", yamlData, "utf8");
              console.log("‚úÖ YAML generated to ./9PB");

              if (!dryRun) {
                // --- Update GitHub file ---
                try {
                  console.log("üì§ Updating GitHub file...");
                  const fileInfo = await axios.get(
                    `https://api.github.com/repos/Vanic24/VPN/contents/${GITHUB_FILE}`,
                    { headers: { Authorization: `token ${GH_TOKEN}` } }
                  );
                  await axios.put(
                    `https://api.github.com/repos/Vanic24/VPN/contents/${GITHUB_FILE}`,
                    {
                      message: "Auto update Clash YAML",
                      content: Buffer.from(yamlData).toString('base64'),
                      sha: fileInfo.data.sha
                    },
                    { headers: { Authorization: `token ${GH_TOKEN}` } }
                  );
                  console.log("‚úÖ GitHub updated");
                } catch (e) {
                  console.error("‚ö†Ô∏è GitHub update failed:", e.message);
                }

                // --- Update igdux with retries ---
                const headers = {
                  'Content-Type': 'text/plain',
                  'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
                  'Referer': 'https://igdux.top/',
                  'Origin': 'https://igdux.top',
                  'Accept': '*/*'
                };

                let success = false;
                for (let attempt = 1; attempt <= 3; attempt++) {
                  try {
                    console.log(`üì§ Updating igdux (attempt ${attempt}/3)...`);
                    await axios.put(IGDUX_EDIT_URL, yamlData, { headers, timeout: 15000 });
                    console.log("‚úÖ igdux updated");
                    success = true;
                    break;
                  } catch (e) {
                    console.error(`‚ö†Ô∏è igdux update failed (attempt ${attempt}):`, e.message);
                    if (attempt < 3) {
                      await new Promise(r => setTimeout(r, 2000 * attempt)); // backoff
                    }
                  }
                }
                if (!success) {
                  console.error("‚ùó Gave up updating igdux after 3 attempts.");
                }
              } else {
                console.log("‚ö†Ô∏è Dry run enabled ‚Äî not pushing to GitHub or igdux.");
              }
            } catch (err) {
              console.error("‚ùå Fatal error:", err.message);
              process.exit(1);
            }
          })();
          EOF

      - name: Upload Clash YAML artifact
        uses: actions/upload-artifact@v4
        with:
          name: 9PB
          path: 9PB
          retention-days: 1

      - name: Delete old artifacts (keep newest named 9PB)
        uses: actions/github-script@v7
        with:
          script: |
            const all = await github.rest.actions.listArtifactsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });
            const targets = all.data.artifacts
              .filter(a => a.name === '9PB' && !a.expired)
              .sort((a, b) => new Date(b.created_at) - new Date(a.created_at)); // newest first
            for (const [i, art] of targets.entries()) {
              if (i === 0) continue; // keep newest
              await github.rest.actions.deleteArtifact({
                owner: context.repo.owner,
                repo: context.repo.repo,
                artifact_id: art.id
              });
              core.info(`üóë Deleted old artifact ${art.id} (${art.name}) created ${art.created_at}`);
            }

      - name: Delete old workflow runs (keep latest)
        uses: actions/github-script@v7
        with:
          script: |
            const runs = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: context.workflow,
              per_page: 50
            });
            const sorted = runs.data.workflow_runs
              .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
            for (const [i, run] of sorted.entries()) {
              if (i === 0 || run.id === context.runId) continue; // keep latest & current
              try {
                await github.rest.actions.deleteWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: run.id
                });
                core.info(`üóë Deleted old run ${run.id} from ${run.created_at}`);
              } catch (e) {
                core.warning(`Could not delete run ${run.id}: ${e.message}`);
              }
